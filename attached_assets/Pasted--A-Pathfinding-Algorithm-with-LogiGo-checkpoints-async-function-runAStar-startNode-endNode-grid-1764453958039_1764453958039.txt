// A* Pathfinding Algorithm with LogiGo checkpoints
async function runAStar(startNode, endNode, grid) {
    await LogiGo.checkpoint('astar:start', {
        variables: { start: startNode, end: endNode }
    });

    const openSet = [startNode];
    const cameFrom = new Map();
    const gScore = new Map();
    const fScore = new Map();

    gScore.set(key(startNode), 0);
    fScore.set(key(startNode), heuristic(startNode, endNode));

    const visited = new Set();

    while (openSet.length > 0) {
        // Find node with lowest fScore
        let current = openSet.reduce((a, b) =>
            (fScore.get(key(a)) ?? Infinity) < (fScore.get(key(b)) ?? Infinity) ? a : b
        );

        // Visual: Highlight current node processing
        await LogiGo.checkpoint(`process:${current.x}:${current.y}`, {
            domElement: `#cell-${current.x}-${current.y}`,
            color: '#f1c40f',
            variables: {
                x: current.x,
                y: current.y,
                f: fScore.get(key(current)).toFixed(1)
            }
        });

        if (current.x === endNode.x && current.y === endNode.y) {
            await reconstructPath(cameFrom, current);
            return;
        }

        openSet.splice(openSet.indexOf(current), 1);
        visited.add(key(current));

        for (const neighbor of getNeighbors(current, grid)) {
            if (visited.has(key(neighbor))) continue;

            const tentativeGScore = (gScore.get(key(current)) ?? Infinity) + 1;

            if (tentativeGScore < (gScore.get(key(neighbor)) ?? Infinity)) {
                cameFrom.set(key(neighbor), current);
                gScore.set(key(neighbor), tentativeGScore);
                fScore.set(key(neighbor), tentativeGScore + heuristic(neighbor, endNode));

                if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                    openSet.push(neighbor);
                    
                    // Visual: Highlight neighbor discovery
                    await LogiGo.checkpoint(`discover:${neighbor.x}:${neighbor.y}`, {
                        domElement: `#cell-${neighbor.x}-${neighbor.y}`,
                        color: '#a8e6cf'
                    });
                }
            }
        }
    }
    await LogiGo.checkpoint('astar:fail', { color: '#e74c3c' });
}

function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function key(node) {
    return `${node.x},${node.y}`;
}