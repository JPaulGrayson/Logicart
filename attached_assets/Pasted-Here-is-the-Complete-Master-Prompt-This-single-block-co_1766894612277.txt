Here is the Complete Master Prompt.
This single block contains every code fix and documentation update we discussed today. You can copy this entire block and paste it into Replit's AI Agent. It will force the codebase into the correct, "Golden Master" state.
ðŸ“œ LogiGo Golden Master Update Prompt
Copy everything between the lines below and paste it into Replit.
I need to force the codebase into a "Golden Master" state to resolve all architectural issues and update documentation.

Please **overwrite** the following 5 files with the exact content provided below. Do not modify the logic; use this exact code.

### 1. FILE: `packages/logigo-embed/src/LogiGoEmbed.tsx`
**Changes:** Fixes Ghost UI (HMR support), removes heavy Dagre import (lazy load), adds session syncing.

```typescript
import React, { useState, useEffect, useMemo } from 'react';
import { ReactFlow, Background, Controls, Node, Edge, ReactFlowProvider, useNodesState, useEdgesState, useReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import * as acorn from 'acorn';
import { LogiGoEmbedProps, EmbedState, LogiGoManifest, CheckpointPayload, FlowNode as ManifestFlowNode, FlowEdge as ManifestFlowEdge } from './types';

// ... (Keep existing Helper Types & Functions: parseCode, convertManifestToFlowData, DecisionNode) ...
// NOTE TO REPLIT: Keep the helper functions 'parseCode', 'convertManifestToFlowData', 'DecisionNode', 'nodeTypes' and 'FlowchartPanel' as they were. 
// Only replace the main LogiGoEmbed component logic below.

export function LogiGoEmbed({
  code,
  manifestUrl,
  manifestHash,
  position = 'bottom-right',
  defaultOpen = true,
  defaultSize = { width: 400, height: 300 },
  showVariables = true,
  showHistory = false,
  theme = 'dark',
  onNodeClick,
  onCheckpoint,
  onManifestLoad,
  onReady,
  onError
}: LogiGoEmbedProps) {
  const [state, setState] = useState<EmbedState>({
    isOpen: defaultOpen,
    size: defaultSize,
    activeNodeId: null,
    variables: {},
    checkpointHistory: []
  });
  
  const [manifest, setManifest] = useState<LogiGoManifest | null>(null);
  const [manifestNodes, setManifestNodes] = useState<any[]>([]);
  const [manifestEdges, setManifestEdges] = useState<any[]>([]);
  const [parsedNodes, setParsedNodes] = useState<any[]>([]);
  const [parsedEdges, setParsedEdges] = useState<any[]>([]);
  const [isLiveMode, setIsLiveMode] = useState(false);
  const [sessionHash, setSessionHash] = useState<string | null>(null);

  // 1. Lazy Load Dagre (Static Mode Only)
  useEffect(() => {
    if (code && !manifestUrl) {
      import('dagre').then((dagreModule) => {
        const dagre = dagreModule.default || dagreModule;
        try {
          // Assuming parseCode is defined above
          const { nodes, edges } = parseCode(code);
          
          const g = new dagre.graphlib.Graph();
          g.setGraph({ rankdir: 'TB', nodesep: 50, ranksep: 70 });
          g.setDefaultEdgeLabel(() => ({}));
          
          nodes.forEach(node => {
            const isDecision = node.type === 'decision';
            g.setNode(node.id, { width: isDecision ? 100 : 150, height: isDecision ? 100 : 50 });
          });
          edges.forEach(edge => g.setEdge(edge.source, edge.target));
          dagre.layout(g);
          
          const layoutedNodes = nodes.map(node => {
            const pos = g.node(node.id);
            return { 
              ...node, 
              position: { 
                x: pos.x - (node.type === 'decision' ? 50 : 75), 
                y: pos.y - (node.type === 'decision' ? 50 : 25) 
              } 
            };
          });

          setParsedNodes(layoutedNodes);
          setParsedEdges(edges);
        } catch (err) {
          onError?.(err as Error);
        }
      });
    }
  }, [code, manifestUrl, onError]);

  const nodes = isLiveMode ? manifestNodes : parsedNodes;
  const edges = isLiveMode ? manifestEdges : parsedEdges;

  // 2. Fetch Manifest
  useEffect(() => {
    if (!manifestUrl) return;

    async function fetchManifest() {
      try {
        const response = await fetch(manifestUrl!);
        if (!response.ok) throw new Error(`Failed to fetch manifest: ${response.status}`);
        
        const data: LogiGoManifest = await response.json();
        
        if (manifestHash && data.hash !== manifestHash) {
          console.warn('[LogiGo] Manifest hash mismatch, may be stale');
        }
        
        setManifest(data);
        setSessionHash(data.hash);
        
        // Assuming convertManifestToFlowData is defined above
        const { nodes, edges } = convertManifestToFlowData(data);
        setManifestNodes(nodes);
        setManifestEdges(edges);
        setIsLiveMode(true);
        
        onManifestLoad?.(data);
        console.log(`[LogiGo] Loaded manifest with ${nodes.length} nodes`);
      } catch (error) {
        console.error('[LogiGo] Failed to load manifest:', error);
        onError?.(error as Error);
      }
    }

    fetchManifest();
  }, [manifestUrl, manifestHash, onManifestLoad, onError]);

  // 3. Handle Runtime Messages (HMR & Checkpoints)
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.source !== 'LOGIGO_CORE') return;
      
      // A. Handle Session Start / HMR Refresh
      if (event.data.type === 'LOGIGO_MANIFEST_READY') {
        const { manifestUrl: url, manifestHash: newHash, sessionId } = event.data.payload;
        
        if (manifest && manifest.hash !== newHash) {
          console.log('[LogiGo] Code changed (HMR). Refreshing manifest...');
          fetch(url)
            .then(res => res.json())
            .then((data: LogiGoManifest) => {
              setManifest(data);
              setSessionHash(newHash);
              const { nodes, edges } = convertManifestToFlowData(data);
              setManifestNodes(nodes);
              setManifestEdges(edges);
              setIsLiveMode(true);
              // Reset history on code change
              setState(prev => ({ ...prev, checkpointHistory: [], activeNodeId: null }));
            })
            .catch(err => console.error('[LogiGo] Failed to refresh manifest:', err));
        } else {
           setSessionHash(newHash);
        }
      }
      
      // B. Handle Checkpoints
      if (event.data.type === 'LOGIGO_CHECKPOINT') {
        const payload = event.data.payload as CheckpointPayload;
        const { id, variables, timestamp, manifestVersion } = payload;
        
        // Ignore checkpoints from old versions
        if (sessionHash && manifestVersion && manifestVersion !== sessionHash) {
           return; 
        }
        
        setState(prev => ({
          ...prev,
          activeNodeId: id,
          variables: variables || {},
          checkpointHistory: [...prev.checkpointHistory, { id, timestamp, variables: variables || {} }]
        }));
        
        onCheckpoint?.(payload);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [manifest, sessionHash, onCheckpoint]);

  useEffect(() => {
    if (nodes.length > 0) {
      onReady?.();
    }
  }, [nodes, onReady]);

  // ... (Keep render logic: positionStyles, return JSX, etc.) ...
  // NOTE TO REPLIT: Keep the JSX render block exactly as it was.
}

export default LogiGoEmbed;

2. FILE: packages/logigo-core/src/runtime.ts
Changes: Adds Deferred Serialization and Queue Throttling (Safety Valve).
import type { CheckpointData, RuntimeOptions, Breakpoint, LogiGoMessage } from './types';

export class LogiGoRuntime {
  private queue: CheckpointData[] = [];
  private flushScheduled = false;
  private manifestHash: string;
  private breakpoints = new Map<string, Breakpoint>();
  private pausePromise: Promise<void> | null = null;
  private resumeCallback: (() => void) | null = null;
  private sessionId: string;
  private started = false;
  private queueOverflowWarned = false;
  private readonly MAX_QUEUE_SIZE = 5000;

  constructor(options: RuntimeOptions = {}) {
    this.manifestHash = options.manifestHash || '';
    this.sessionId = this.generateSessionId();
  }

  private generateSessionId(): string {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return 'session_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  start(): void {
    if (this.started) return;
    this.started = true;
    this.postMessage({
      source: 'LOGIGO_CORE',
      type: 'LOGIGO_SESSION_START',
      payload: { sessionId: this.sessionId, manifestHash: this.manifestHash, timestamp: Date.now() }
    });
  }

  end(): void {
    if (!this.started) return;
    this.flush();
    this.postMessage({
      source: 'LOGIGO_CORE',
      type: 'LOGIGO_SESSION_END',
      payload: { sessionId: this.sessionId, timestamp: Date.now() }
    });
    this.started = false;
  }

  checkpoint(id: string, variables?: Record<string, any>): void {
    if (!this.started) this.start();

    // SAFETY VALVE: Prevent OOM on infinite loops
    if (this.queue.length >= this.MAX_QUEUE_SIZE) {
      if (!this.queueOverflowWarned) {
        console.warn(`[LogiGo] Queue overflow (${this.MAX_QUEUE_SIZE}). Dropping checkpoints.`);
        this.queueOverflowWarned = true;
      }
      return;
    }

    // FAST PATH: Shallow copy only
    const rawVariables = variables ? { ...variables } : {};

    this.queue.push({
      id,
      rawVariables, // Store raw
      timestamp: Date.now(),
      manifestVersion: this.manifestHash
    } as any);

    if (!this.flushScheduled) {
      this.flushScheduled = true;
      queueMicrotask(() => this.flush());
    }
  }

  async checkpointAsync(id: string, variables?: Record<string, any>): Promise<void> {
    this.checkpoint(id, variables);
    const bp = this.breakpoints.get(id);
    if (bp && bp.enabled) {
      if (!bp.condition || this.evaluateCondition(bp.condition, variables || {})) {
        await this.waitForResume();
      }
    }
  }

  // ... (Keep Breakpoint/Resume/Condition methods as they were) ...

  private flush(): void {
    const batch = this.queue.splice(0);
    this.flushScheduled = false;
    this.queueOverflowWarned = false;

    batch.forEach(data => {
      // HEAVY PATH: Serialize off-thread (microtask)
      const serializedVariables = this.safeSerialize((data as any).rawVariables);
      
      this.postMessage({
        source: 'LOGIGO_CORE',
        type: 'LOGIGO_CHECKPOINT',
        payload: {
          id: data.id,
          timestamp: data.timestamp,
          manifestVersion: data.manifestVersion,
          variables: serializedVariables
        }
      });
    });
  }

  private postMessage(message: LogiGoMessage): void {
    if (typeof window !== 'undefined') window.postMessage(message, '*');
  }

  private safeSerialize(obj: Record<string, any>): Record<string, any> {
    const result: Record<string, any> = {};
    for (const [key, value] of Object.entries(obj)) {
      try {
        if (value === undefined) result[key] = undefined;
        else if (value === null) result[key] = null;
        else if (typeof value === 'function') result[key] = '[Function]';
        else if (typeof value === 'symbol') result[key] = value.toString();
        else if (typeof value === 'object') {
          result[key] = Array.isArray(value) ? '[Array]' : '[Object]';
        } else {
          result[key] = value;
        }
      } catch { result[key] = '[Error]'; }
    }
    return result;
  }
  
  // ... (Keep existing exports: createRuntime, checkpoint, global window logic) ...
}

3. FILE: packages/logigo-vite-plugin/src/index.ts
Changes: Updates the injected runtime string to match the Core runtime logic.
import type { Plugin, ResolvedConfig } from 'vite';
import { instrumentFile } from './instrumenter';
import { generateFileChecksum, generateManifestHash } from './hash';
import type { LogiGoManifest, LogiGoPluginOptions, FlowNode, FlowEdge, CheckpointMetadata } from './types';

// ... (Keep existing logigoPlugin function setup) ...

// REPLACE the 'runtimeInit' string variable inside generateBundle with this:

      const runtimeInit = `
;(function() {
  var MANIFEST_HASH = '${manifestHash}';
  var MANIFEST_URL = '/${manifestPath}';
  
  window.__LOGIGO_MANIFEST_HASH__ = MANIFEST_HASH;
  window.__LOGIGO_MANIFEST_URL__ = MANIFEST_URL;
  
  function generateSessionId() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
    return 'session_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  
  function safeSerialize(obj) {
    var result = {};
    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) continue;
      try {
        var value = obj[key];
        if (typeof value === 'object' && value !== null) {
          result[key] = Array.isArray(value) ? '[Array]' : '[Object]';
        } else if (typeof value === 'function') {
          result[key] = '[Function]';
        } else {
          result[key] = value;
        }
      } catch (e) { result[key] = '[Error]'; }
    }
    return result;
  }
  
  var LogiGoRuntime = {
    _queue: [],
    _flushScheduled: false,
    _sessionId: generateSessionId(),
    _manifestHash: MANIFEST_HASH,
    _breakpoints: {},
    _started: false,
    _pauseResolve: null,
    _queueOverflowWarned: false,
    MAX_QUEUE_SIZE: 5000,
    
    start: function() {
      if (this._started) return;
      this._started = true;
      this._postMessage('LOGIGO_SESSION_START', {
        sessionId: this._sessionId,
        manifestHash: this._manifestHash,
        timestamp: Date.now()
      });
    },
    
    end: function() {
      if (!this._started) return;
      this._flush();
      this._postMessage('LOGIGO_SESSION_END', { sessionId: this._sessionId, timestamp: Date.now() });
      this._started = false;
    },
    
    checkpoint: function(id, variables) {
      if (!this._started) this.start();
      
      if (this._queue.length >= this.MAX_QUEUE_SIZE) {
        if (!this._queueOverflowWarned) {
          console.warn('[LogiGo] Queue overflow. Dropping checkpoints.');
          this._queueOverflowWarned = true;
        }
        return;
      }
      
      var rawVariables = variables ? Object.assign({}, variables) : {};
      
      this._queue.push({
        id: id,
        rawVariables: rawVariables,
        timestamp: Date.now(),
        manifestVersion: this._manifestHash
      });
      
      if (!this._flushScheduled) {
        this._flushScheduled = true;
        queueMicrotask(this._flush.bind(this));
      }
    },
    
    checkpointAsync: function(id, variables) {
      var self = this;
      this.checkpoint(id, variables);
      var bp = this._breakpoints[id];
      if (bp && bp.enabled) {
        return new Promise(function(resolve) { self._pauseResolve = resolve; });
      }
      return Promise.resolve();
    },
    
    setBreakpoint: function(id, enabled, condition) {
      this._breakpoints[id] = { id: id, enabled: enabled !== false, condition: condition };
    },
    removeBreakpoint: function(id) { delete this._breakpoints[id]; },
    clearBreakpoints: function() { this._breakpoints = {}; },
    resume: function() {
      if (this._pauseResolve) {
        this._pauseResolve();
        this._pauseResolve = null;
      }
    },
    
    _flush: function() {
      var batch = this._queue.splice(0);
      this._flushScheduled = false;
      this._queueOverflowWarned = false;
      var self = this;
      
      batch.forEach(function(data) {
        var serialized = safeSerialize(data.rawVariables);
        self._postMessage('LOGIGO_CHECKPOINT', {
          id: data.id,
          timestamp: data.timestamp,
          manifestVersion: data.manifestVersion,
          variables: serialized
        });
      });
    },
    
    _postMessage: function(type, payload) {
      if (typeof window !== 'undefined') {
        window.postMessage({ source: 'LOGIGO_CORE', type: type, payload: payload }, '*');
      }
    }
  };
  
  window.LogiGo = LogiGoRuntime;
  
  LogiGoRuntime._postMessage('LOGIGO_MANIFEST_READY', {
    manifestUrl: MANIFEST_URL + '?v=' + MANIFEST_HASH,
    manifestHash: MANIFEST_HASH,
    sessionId: LogiGoRuntime._sessionId
  });
})();
`;

// ... (Keep remainder of the file) ...

4. FILE: packages/logigo-embed/rollup.config.js
Changes: Creates missing build config to compile the package.
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import typescript from '@rollup/plugin-typescript';
import peerDepsExternal from 'rollup-plugin-peer-deps-external';
import postcss from 'rollup-plugin-postcss';

import pkg from './package.json' assert { type: "json" };

export default [
  {
    input: 'src/index.ts',
    output: [
      {
        file: pkg.main,
        format: 'cjs',
        sourcemap: true,
      },
      {
        file: pkg.module,
        format: 'esm',
        sourcemap: true,
      },
    ],
    plugins: [
      peerDepsExternal(),
      resolve(),
      commonjs(),
      typescript({ tsconfig: './tsconfig.json' }),
      postcss({
        extensions: ['.css'],
        minimize: true,
        inject: true
      })
    ],
    external: ['react', 'react-dom', '@xyflow/react']
  }
];

5. FILE: README.md
Changes: Updates root docs to reflect the new Vite Plugin architecture.
# LogiGo: The Embeddable Visual Debugger

LogiGo transforms your JavaScript/TypeScript code into interactive, step-by-step flowcharts **inside your own app**.

## ðŸš€ Quick Start (Vite + React)

### 1. Install Packages
```bash
npm install logigo-embed
npm install logigo-vite-plugin --save-dev

2. Configure Vite Plugin
// vite.config.ts
import logigoPlugin from 'logigo-vite-plugin';

export default defineConfig({
  plugins: [
    react(),
    logigoPlugin({
      include: ['src/**/*.tsx', 'src/**/*.ts'],
      manifestPath: 'logigo-manifest.json' 
    })
  ]
});

3. Add the Embed Component
import { LogiGoEmbed } from 'logigo-embed';

function App() {
  return (
    <LogiGoEmbed 
      manifestUrl="/logigo-manifest.json"
      position="bottom-right"
      theme="dark"
    />
  );
}

ðŸ› ï¸ How It Works
 * Build Time: The plugin generates a logigo-manifest.json and injects invisible checkpoints.
 * Run Time: Checkpoints flow to the Embed component via a background message bus.
 * Safety: Includes infinite loop protection (drops checkpoints if >5000 queued).
<!-- end list -->

