{
  "code": "// LogicArt Dogfood: Interpreter.prepare() method\n// This is LogicArt visualizing its own execution engine!\n\nfunction prepare(functionName, args) {\n  if (!this.ast) return false;\n  \n  this.reset();\n  this.steps = [];\n  this.stepLimitExceeded = false;\n  this.crashPathData = null;\n  this.state.status = 'running';\n  \n  const body = this.ast.body;\n  \n  // Build a map of function declarations\n  this.functionDeclarations = new Map();\n  for (const node of body) {\n    if (node.type === 'FunctionDeclaration' && node.id) {\n      this.functionDeclarations.set(node.id.name, node);\n    }\n  }\n  \n  // Collect top-level statements (not function declarations)\n  const topLevelStatements = body.filter(node => \n    node.type !== 'FunctionDeclaration'\n  );\n  \n  // Execute top-level statements if they exist\n  if (topLevelStatements.length > 0) {\n    this.collectSteps(topLevelStatements);\n    \n    if (this.stepLimitExceeded) {\n      this.buildCrashPathData();\n      this.state.status = 'error';\n      this.state.error = 'Infinite loop detected!';\n      return false;\n    }\n    \n    return this.steps.length > 0;\n  }\n  \n  // Fallback: Find and execute a specific function\n  const targetFunction = body.find(node => \n    node.type === 'FunctionDeclaration' && \n    (!functionName || node.id.name === functionName)\n  );\n  \n  if (!targetFunction) {\n    this.state.error = 'Function not found';\n    this.state.status = 'error';\n    return false;\n  }\n  \n  // Initialize function parameters\n  if (targetFunction.params && args) {\n    targetFunction.params.forEach((param, idx) => {\n      this.setVariable(param.name, args[idx]);\n    });\n  }\n  \n  // Collect all execution steps\n  this.collectSteps(targetFunction.body.body);\n  \n  if (this.stepLimitExceeded) {\n    this.buildCrashPathData();\n    this.state.status = 'error';\n    this.state.error = 'Infinite loop detected!';\n    return false;\n  }\n  \n  return true;\n}"
}
